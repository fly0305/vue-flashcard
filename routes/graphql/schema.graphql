#import deck/*.graphql
#import card/*.graphql
#import user/*.graphql
#import auth.graphql
"Can be used as an argument to upload files"
scalar Upload @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Upload")


"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-01-01 13:00:00`."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

#Think of queries as REST resources which can take arguments and return a fixed result.

type Language {
    id: Int!
    locale: String!
    name: String!
}

type User {
    id: Int!,
    username: String!
    email: String!
    cards_count: Int! @count(relation: "publishedCards")
    decks: [Deck!]! @hasMany(scopes: ["Published"]) @lazyLoad(relations: ["decks"])
    cards: [Card!]! @hasMany(scopes: ["Published"]) @lazyLoad(relations: ["cards"])
}


type Query {
    users: [User!]! @paginate(defaultCount: 10)
    profile(username: String! @eq): User @find
    deck(id: ID @eq): Deck @find
    me: User! @middleware(checks:["auth:api"]) @auth(guard: "api")
    user(username: String! @eq): User @find
    decks(search: String @search, filter: [FilterClause!] @filter): [Deck!]! @paginate(model: "App\\Deck",defaultCount: 12)
    languages: [Language!]! @all
}


input OrderByClause{
    field: String!
    order: SortOrder!
}


enum SortOrder {
    ASC
    DESC
}

input FilterClause{
    field: String!
    order: FilterOrder!
    orderByCount: CountInput
}

enum FilterOrder {
    ASC
    DESC
    RAND
}

input CountInput {
    model: String!
    relation: String!
}


input LoginInput {
      login: String
      password: String
}

input RegisterInput {
    email: String
    password: String
    password_confirmation: String
}

type LoginResponse {
     access_token: String!
     refresh_token: String!
     expires_in: DateTime!
     user: User!
}

type RefreshResponse {
     access_token: String!
     refresh_token: String!
     expires_in: DateTime!
}

type LogoutResponse {
    status: String!
    message: String
}


type Mutation @middleware(checks: ["auth:api"]) {

      editProfile(
          id: Int!
          username: String
          email: String
          password: String
          ): User @update @editProfile

          removeProfile(
          id: Int!
          ): User @delete

  createDeck(input: CreateDeckInput! @spread): Deck! @field(resolver: "App\\GraphQL\\Mutations\\DeckMutator@createDeck")

}



extend type Mutation {


          updateDeck(input: CreateCardInput! @spread): Deck @update
          removeDeck(input: CreateCardInput! @spread): Deck @delete

          logout: LogoutResponse!
      @field(resolver: "App\\GraphQL\\Resolvers\\AuthResolver@logout")

    login(data: LoginInput @spread): LoginResponse!
    @field(resolver: "App\\GraphQL\\Resolvers\\AuthResolver@login")

refresh_token(refresh: Boolean): RefreshResponse!
    @field(resolver: "App\\GraphQL\\Resolvers\\AuthResolver@refresh_token")

    register(data:
        RegisterInput @spread
    ): LoginResponse!
    @field(resolver: "App\\GraphQL\\Resolvers\\AuthResolver@register")
}

input CreateDeckInput {
    title: String!
    description: String!
    lang_source_id: Int!
    lang_target_id: Int!
    visibility: Visibility!
    image: String!
    cards: [CreateCardInput!]
}

input CreateCardInput {
    question: String!
    answer: String!
    example_question: String!
    example_answer: String!
    image: String!
}


input UpdateCardInput {
    id: ID!
    question: String!
    answer: String!
    example_question: String!
    example_answer: String!
    image: String!
}

input UpsertCardInput {
    id: ID!
    question: String!
    answer: String!
    example_question: String!
    example_answer: String!
    image: String!
}
